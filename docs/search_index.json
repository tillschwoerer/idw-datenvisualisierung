[["index.html", "Einführung in die Datenvisualisierung mit R IDW Workshop 1 Einleitung 1.1 Dieses Buch 1.2 R und RStudio 1.3 Datenmanipulation", " Einführung in die Datenvisualisierung mit R IDW Workshop Prof. Dr. Tillmann Schwörer, FH Kiel, Studiengang Data Science 2021-11-02 1 Einleitung An dieser Stelle stichpunktartig ein paar zentrale Informationen zur Motivation dieses Buches, sowie einige Starthilfen zum Arbeiten mit R. 1.1 Dieses Buch Ein Bild sagt mehr als 1000 Worte, sagt das Sprichwort. Ganz in diesem Sinne sind Visualisierungen eine wirkungsvolle Technik, um komplexe Zusammenhänge in Daten zu analysieren und für andere greifbar zu machen. Was benötigen wir für derart wirkungsvolle Visualisierungen? (1) Interessante und komplexe Daten, (2) Leitlinien/Reflektion, was eine gute Grafik ausmacht, (3) Kenntnisse, wie wir Visualisierungen (mithilfe der Programmiersprache R) umsetzen können. Der Fokus dieses Buches liegt auf letzterem Punkt. Es demonstriert, wie mithilfe des R Paketes ggplot2 unterschiedlichste Arten von Daten und Fragestellungen visuell dargestellt werden können. Diese Demonstration erfolgt anhand von drei verschiedenen Datensätzen: (1) Daten zu Gebrauchtwagen, die über Ebay-Kleinanzeigen verkauft wurden. Die hier verwendeten Daten stellen einen Ausschnitt aus einem noch größeren Datensatz dar, der über die Plattform Kaggle erhältlich ist. (2) Ausgewählte Informationen der World Development Indicators von der Weltbank. (3) Daten zu Luft-Schadstoffmessungen an ausgewählten Standorten in Deutschland seit 2006. 1.2 R und RStudio Dieses Buch ist keine Einführung in die Programmiersprache R. Daher an dieser Stelle nur ein sehr kondensierte Zusammenfassung wesentlicher Aspekte. R ist eine Software für statistische Berechnungen und Grafiken. RStudio ist eine integrierte Entwicklungsumgebung (IDE) für R. Wir werden in diesem Kurs ausschließlich über RStudio mit R arbeiten (wobei dies bspw. auch über die Kommandozeile, Jupyter Notebooks, oder andere IDEs möglich ist) Die Funktionalität der Basisinstallation lässt sich über R Pakete in jede denkbare Richtung erweitern (Datenaufbereitung, Visualisierung, Maschinelles Lernen, ). Pakete können von jedermann geschrieben werden und über Plattformen wie CRAN oder Github der Allgemeinheit zur Verfügung gestellt werden. Pakete müssen grundsätzlich nur 1 mal installiert werden, wobei ein gelegentliches Update Sinn macht. Jedes Mal, wenn die Funktionalität des Paketes in ein R Skript einebunden werden soll, muss das Paket über den library Befehl geladen werden. Dieser Kurs nutzt insbesondere das R Paket tidyverse. Genauer gesagt handelt es sich dabei um eine Sammlung mehrerer Pakete. Enthalten ist darin insbesondere das Paket ggplot2, welches wir für die Visualisierungen verwendet werden. An dieser Stelle auch der Hinweis, dass sich die Syntax des tidyverse teilweise deutlich von base R Syntax unterscheidet. Programmcode kann einerseits in R Skripten (Dateiendung: .R) und R Markdown Dateien (.Rmd) geschrieben werden. Erstere eignen sich insbesondere, wenn der Programmcode im Vordergrund steht. Letztere eignen sich insbesondere, wenn auch Erläuterungen und die Präsentation von Ergebnissen wichtig sind. 1.3 Datenmanipulation Die wichtigsten Operationen zur Datenmanipulation werden nun ganz kurz angerissen: Zu Beginn der R Dateien sind die benötigten Pakete einzubinden. library(tidyverse) Anschließend lesen wir die Daten ein. df &lt;- read_csv(&quot;data/gebrauchtwagen.csv&quot;) Die Funktion read_csv ist teil des Paketes tidyverse. Das heißt, sie können die Funktion nur verwenden, wenn sie vorher das Paket geladen haben. In den meisten Fällen werden wir Daten von Komma-separierte Datein (.csv) einlesen. Gelegentich werden wir auch Dateien mit dem R spezifischen Typ .rds einlesen.Der Pfeil Operator &lt;- verwenden wir, um ein bestimmtes Object (hier: ein Datensatz) einem Namen (hier: df) zuzuweisen. Nun erscheint der Datensatz unter diesem Namen im Environment Tab von RStudio Einen schnellen Überblick über einen Datensatz können wir uns mithilfe der folgenden Funktionen verschaffen: glimpse(df) # Kurzvorschau jeder Variable mit einigen Metadaten ## Rows: 20,000 ## Columns: 13 ## $ name &lt;chr&gt; &quot;smart_forTwo_Softtouch__passion_Inspektion_fuer_687_Euro_~ ## $ preis &lt;dbl&gt; 5299, 1100, 8199, 8999, 3600, 2490, 15500, 2700, 6200, 279~ ## $ alter &lt;dbl&gt; 7, 16, 14, 8, 13, 11, 7, 12, 8, 8, 22, 8, 9, 15, 16, 18, 1~ ## $ kilometer &lt;dbl&gt; 30000, 125000, 150000, 150000, 150000, 150000, 150000, 900~ ## $ hersteller &lt;chr&gt; &quot;smart&quot;, &quot;renault&quot;, &quot;audi&quot;, &quot;mercedes_benz&quot;, &quot;bmw&quot;, &quot;peuge~ ## $ modell &lt;chr&gt; &quot;fortwo&quot;, &quot;clio&quot;, &quot;a4&quot;, &quot;c_klasse&quot;, &quot;3er&quot;, &quot;1_reihe&quot;, &quot;5er~ ## $ fahrzeugtyp &lt;chr&gt; &quot;kleinwagen&quot;, &quot;kleinwagen&quot;, &quot;kombi&quot;, &quot;limousine&quot;, &quot;limousi~ ## $ getriebe &lt;chr&gt; &quot;automatik&quot;, &quot;manuell&quot;, &quot;automatik&quot;, &quot;automatik&quot;, &quot;manuell~ ## $ ps &lt;dbl&gt; 71, 75, 131, 136, 116, 68, 177, 69, 125, 67, 115, 121, 129~ ## $ kraftstoff &lt;chr&gt; &quot;benzin&quot;, &quot;benzin&quot;, &quot;benzin&quot;, &quot;diesel&quot;, &quot;benzin&quot;, &quot;diesel&quot;~ ## $ schaden &lt;chr&gt; &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;j~ ## $ plz &lt;dbl&gt; 35315, 36137, 85057, 10627, 65934, 14793, 28816, 30880, 71~ ## $ bundesland &lt;chr&gt; &quot;Hessen&quot;, &quot;Hessen&quot;, &quot;Bayern&quot;, &quot;Berlin&quot;, &quot;Hessen&quot;, &quot;Branden~ head(df) # Erste 6 Zeilen ## # A tibble: 6 x 13 ## name preis alter kilometer hersteller modell fahrzeugtyp getriebe ps ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 smart_forT~ 5299 7 30000 smart fortwo kleinwagen automat~ 71 ## 2 Renault_Cl~ 1100 16 125000 renault clio kleinwagen manuell 75 ## 3 Audi_A4_Av~ 8199 14 150000 audi a4 kombi automat~ 131 ## 4 Mercedes_B~ 8999 8 150000 mercedes_~ c_kla~ limousine automat~ 136 ## 5 BMW_316_i_~ 3600 13 150000 bmw 3er limousine manuell 116 ## 6 verk._eine~ 2490 11 150000 peugeot 1_rei~ kleinwagen manuell 68 ## # ... with 4 more variables: kraftstoff &lt;chr&gt;, schaden &lt;chr&gt;, plz &lt;dbl&gt;, ## # bundesland &lt;chr&gt; Wenn wir genauere Information zu einer R Funktion oder einem Paket benötigen können wir die Hilfe verwenden, z.B. help(head). Wir verwenden die filter Funktion, um alle diejenigen Autos (Zeilen des Datensatzes) zu selektieren, die eine oder mehrere Bedingungen erfüllen. Hier wählen wir alle Autos des Herstellers Porsche mit mehr als 280 PS. 1.3.1 Filter filter(df, hersteller==&#39;porsche&#39; &amp; ps&gt;280) ## # A tibble: 5 x 13 ## name preis alter kilometer hersteller modell fahrzeugtyp getriebe ps ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Porsche_Ca~ 15500 8 150000 porsche cayen~ suv automat~ 290 ## 2 Porsche_99~ 25996 16 125000 porsche 911 cabrio automat~ 300 ## 3 Porsche_Ca~ 18888 9 100000 porsche cayen~ suv automat~ 290 ## 4 Porsche_Bo~ 26900 8 80000 porsche boxst~ cabrio manuell 295 ## 5 Porsche_996 29996 15 125000 porsche 911 cabrio automat~ 300 ## # ... with 4 more variables: kraftstoff &lt;chr&gt;, schaden &lt;chr&gt;, plz &lt;dbl&gt;, ## # bundesland &lt;chr&gt; Alternativ können wir dies unter Verwendung des sog. Pipe Operators (%&gt;%) wie folgt schreiben. df %&gt;% filter(hersteller==&#39;porsche&#39; &amp; ps&gt;280) ## # A tibble: 5 x 13 ## name preis alter kilometer hersteller modell fahrzeugtyp getriebe ps ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Porsche_Ca~ 15500 8 150000 porsche cayen~ suv automat~ 290 ## 2 Porsche_99~ 25996 16 125000 porsche 911 cabrio automat~ 300 ## 3 Porsche_Ca~ 18888 9 100000 porsche cayen~ suv automat~ 290 ## 4 Porsche_Bo~ 26900 8 80000 porsche boxst~ cabrio manuell 295 ## 5 Porsche_996 29996 15 125000 porsche 911 cabrio automat~ 300 ## # ... with 4 more variables: kraftstoff &lt;chr&gt;, schaden &lt;chr&gt;, plz &lt;dbl&gt;, ## # bundesland &lt;chr&gt; 1.3.2 Select und Arrange Der Vorteil des Pipe Operators wird ersichtlich, wenn wir mehrere Verarbeiungsschritte miteinander verketten, bspw. durch Selektion einzelner Spalten (select) und Sortierung (arrange). Der Vorteil besteht darin, dass wir nicht nach jeder Operation ein Zwischenergebnis speichern müssen. df %&gt;% filter(hersteller==&#39;porsche&#39; &amp; ps&gt;280) %&gt;% # Selektion einzelner Zeilen select(hersteller, ps, alter, preis) %&gt;% # Selektion einzelner Spalten arrange(-preis) # Sortieren anhand der Spalte Bevölkerung ## # A tibble: 5 x 4 ## hersteller ps alter preis ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 porsche 300 15 29996 ## 2 porsche 295 8 26900 ## 3 porsche 300 16 25996 ## 4 porsche 290 9 18888 ## 5 porsche 290 8 15500 1.3.3 Mutate Mithilfe der Funktion mutate können wir neue Variablen erstellen, oder alte überschreiben. df %&gt;% select(hersteller, modell, preis) %&gt;% mutate(preis_in_1000 = preis / 1000) %&gt;% head(3) ## # A tibble: 3 x 4 ## hersteller modell preis preis_in_1000 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 smart fortwo 5299 5.30 ## 2 renault clio 1100 1.1 ## 3 audi a4 8199 8.20 Mithilfe der Funktion summarise können wir unterschiedliche aggregierte Statistiken berechnen. Unter help(summarise) können sie wichtige Funktionen sehen, die zur Verfügung stehen. Zu beachten ist die Behandlung von fehlenden Werten (NA, not available). Um trotz vorhandener fehlender Werte ein Ergebnis angezeigt zu bekommen, muss die Option na.rm (remove NAs) auf TRUE gesetzt werden. 1.3.4 Summarise df %&gt;% summarise(anzahl_fahrzeuge = n(), durchschnittliche_kilometer = mean(kilometer, na.rm=TRUE), gesamt_kilometer = sum(kilometer, na.rm=TRUE)) ## # A tibble: 1 x 3 ## anzahl_fahrzeuge durchschnittliche_kilometer gesamt_kilometer ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20000 124122. 2482430000 Häufig kombinieren wir summarise mit der Funktion group_by. Dann wird die Berechnung nicht für den gesamten Datensatz ausgeführt, sondern separat für jede durch group_by definierte Gruppe. 1.3.5 Group by df %&gt;% group_by(schaden) %&gt;% summarise(durchschnitts_preis = mean(preis, na.rm=TRUE)) ## # A tibble: 2 x 2 ## schaden durchschnitts_preis ## &lt;chr&gt; &lt;dbl&gt; ## 1 ja 2173. ## 2 nein 6164. "],["streudiagramme.html", "2 Streudiagramme 2.1 Grundlagen 2.2 Ästhetik-Zuordnung 2.3 Geometrisches Objekt 2.4 Skalierung 2.5 Facetten 2.6 Thema und Labels", " 2 Streudiagramme Alle Visualisierungen in diesem Kurs setzen wir mithilfe des Paketes ggplot2 durch. Es handelt sich dabei um einen Bestandteil des bereits bekannten Paketes tidyverse. Das Paket basiert auf einer Grammar of Graphics (daher das gg in ggplot2), d.h. einem sprachlichen Regelwerk für die einzelnen Bestandteile einer Grafik. Dieses Regewerk kann uns dabei helfen, komplexe Sachverhalte in einfache Grafiken zu überführen. Wir erschließen uns das Paket ggplot2 anhand von Streudiagrammen (scatterplots). Steudiagrmamme sind hilfreich um die Beziehung zwischen 2 (oder mehr) Variablen zu visualisieren. library(tidyverse) theme_set(theme_bw()) # Standard Thema (Hintergrund, etc.) für die Grafiken df &lt;- read_csv(&quot;data/gebrauchtwagen.csv&quot;) # Daten einlesen sample &lt;- df %&gt;% slice(1:500) # Kleiner Datensatz, der die ersten 500 Zeilen umfasst glimpse(sample) ## Rows: 500 ## Columns: 13 ## $ name &lt;chr&gt; &quot;smart_forTwo_Softtouch__passion_Inspektion_fuer_687_Euro_~ ## $ preis &lt;dbl&gt; 5299, 1100, 8199, 8999, 3600, 2490, 15500, 2700, 6200, 279~ ## $ alter &lt;dbl&gt; 7, 16, 14, 8, 13, 11, 7, 12, 8, 8, 22, 8, 9, 15, 16, 18, 1~ ## $ kilometer &lt;dbl&gt; 30000, 125000, 150000, 150000, 150000, 150000, 150000, 900~ ## $ hersteller &lt;chr&gt; &quot;smart&quot;, &quot;renault&quot;, &quot;audi&quot;, &quot;mercedes_benz&quot;, &quot;bmw&quot;, &quot;peuge~ ## $ modell &lt;chr&gt; &quot;fortwo&quot;, &quot;clio&quot;, &quot;a4&quot;, &quot;c_klasse&quot;, &quot;3er&quot;, &quot;1_reihe&quot;, &quot;5er~ ## $ fahrzeugtyp &lt;chr&gt; &quot;kleinwagen&quot;, &quot;kleinwagen&quot;, &quot;kombi&quot;, &quot;limousine&quot;, &quot;limousi~ ## $ getriebe &lt;chr&gt; &quot;automatik&quot;, &quot;manuell&quot;, &quot;automatik&quot;, &quot;automatik&quot;, &quot;manuell~ ## $ ps &lt;dbl&gt; 71, 75, 131, 136, 116, 68, 177, 69, 125, 67, 115, 121, 129~ ## $ kraftstoff &lt;chr&gt; &quot;benzin&quot;, &quot;benzin&quot;, &quot;benzin&quot;, &quot;diesel&quot;, &quot;benzin&quot;, &quot;diesel&quot;~ ## $ schaden &lt;chr&gt; &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;j~ ## $ plz &lt;dbl&gt; 35315, 36137, 85057, 10627, 65934, 14793, 28816, 30880, 71~ ## $ bundesland &lt;chr&gt; &quot;Hessen&quot;, &quot;Hessen&quot;, &quot;Bayern&quot;, &quot;Berlin&quot;, &quot;Hessen&quot;, &quot;Branden~ 2.1 Grundlagen Minimale Angaben zur Erstellung einer Grafik: Datensatz (data) Ästhetik-Zuordnung (aesthetic mapping): Welche Variable des Datensatzes wird durch welche Ästhetik (x-Achse, y-Achse, Farbe, Größe, Form, ) repräsentiert? Geometrisches Objekt (geometric object): z.B. Punkte, Linien, Balken, etc. ggplot(data = sample, mapping = aes(x = alter, y = preis)) + geom_point() Wie ändert sich die Grafik, wenn wir den vollen Datensatz (df) verwenden? ggplot(data = df, mapping = aes(x = alter, y = preis)) + geom_point() Wie ändert sich die Grafik, wenn wir eine andere Ästhetik-Zuordnung vornehmen? ggplot(data = sample, mapping = aes(x = preis, y = alter)) + geom_point() ggplot(data = sample, mapping = aes(x = preis, y = hersteller)) + geom_point() ggplot(data = sample, mapping = aes(x = fahrzeugtyp, y = hersteller)) + geom_point() Wie ändert sich die Grafik, wenn wir einen anderen Objekttyp wählen? ggplot(data = sample, mapping = aes(x = fahrzeugtyp, y = hersteller)) + geom_jitter(width = 0.1) ggplot(data = df, mapping = aes(x = alter, y = preis)) + geom_density2d_filled() 2.2 Ästhetik-Zuordnung Über weitere Ästhetik-Zuordnungen (Welche Variable wird durch welche Ästhetik repräsentiert?) können wir eine mehrdimensionale Visualisierung erstellen. Welche Ästhetiken für geom_point zur Verfügung stehen, kann man via help(geom_point) unter der Überschrift Aesthetics nachlesen. Je nach Varialentyp sind unterschiedliche Ästhetiken sinnvoll. 2.2.1 Kardinal-skalierte Variable Für kardinal-skalierte Variablen wie ps (für Pferdestärke) sind beispielsweise die Ästhetiken Farbe (color), Größe (size) und Transparenz (alpha) denkbar, wobei nur die Farbe richtig überzeugt. sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = ps)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, size = ps)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, alpha = ps)) + geom_point() 2.2.2 Nominal-skalierte Variable Für nominal-skalierte Variablen wie fahrzeugtyp eignen sich bspw. die Ästhetiken Farbe (color) und Form (shape). sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = fahrzeugtyp)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, shape = fahrzeugtyp)) + geom_point() 2.2.3 Fixierte Ästhetik Beachten Sie den Unterschied zwischen (1) einer Ästhetik-Zuordnung (aesthetic mapping) und (2) einer fest definierten Ästhetik! Im folgenden Beispiel werden die Ästhetiken Farbe (color), Transparenz (alpha), Größe (size) und Form (shape) auf konkrete Werte festgelegt. Das heißt für jeden dargestellten Datenpunkt wird dieselbe Farbe, Transparenz, etc. verwendet. Hingegen bekommen bei einer Ästhetik-Zuordnung die Datenpunkte unterschiedliche Farben, Transparenzen, etc. in Abhängigkeit vom Wert der jeweiligen Variable des Datensatzes. sample %&gt;% ggplot(mapping = aes(x = alter, y = preis)) + geom_point(color = &quot;#54b856&quot;, alpha = 0.5, size = 3, shape = 18) 2.3 Geometrisches Objekt Grundsätzlich stehen Ihnen eine große Auswahl an Objekttypen zur Verfügung. Aber: Für eine gegebene Fragestellung kommen idR nur wenige davon konkret in Frage. Betrachten wir, welche Objekttypen für die folgende Fragestellung sinnvoll sein könnten: Wie stehen Fahrzeugalter und Preis miteinander in Beziehung? p &lt;- sample %&gt;% ggplot(aes(x = alter, y = preis)) p + geom_point() p + geom_jitter() # zufälliges &quot;Zittern&quot; um Überlappungen zu reduzieren p + geom_smooth() # Geglättete Linie p + geom_density_2d() # Umrisse einer 2-dimensionalen Dichteschätzung Beachten Sie, dass die geom_[typ] Funktionen teilweise implizite Veränderungen an den Daten vornehmen: bspw. statistische Berechnungen (geom_smooth, geom_density_2d) oder Positionsanpassungen (geom_jitter). Diese standardmäßig verwendeten Verändungen können Sie aber auch manuell verhindern bzw. anpassen, bspw: p + geom_smooth(method = &quot;lm&quot;) # Lineare Regressionsgerade Sie können mithilfe der geom Funktionen auch mehrere Datenschichten übereinander legen. Dabei definiert jeder Objekttyp genau eine Schicht. Je Schicht können auch eigene Daten oder eine eigene Ästhetik-Zuordnung verwendet werden. Beispiel 1: Streudiagramm mit Smooth Line p + geom_point() + geom_smooth() Beipsiel 2: Hervorhebung einer Teilmenge der Daten subset &lt;- sample %&gt;% filter(hersteller == &quot;opel&quot;) p + geom_point(color = &quot;grey&quot;, alpha = 0.2) + geom_point(data = subset, aes(color = hersteller)) Beispiel 3: Labels für interessante Datenpunkte subset &lt;- sample %&gt;% filter(preis==max(preis) | alter==max(alter)) p + geom_point() + ggrepel::geom_label_repel(data = subset, mapping = aes(label = name), min.segment.length = 0.1) Beispiel 4: Streudiagramm mit mehreren Smooth Lines sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = fahrzeugtyp)) + geom_point() + geom_smooth(se=FALSE) 2.4 Skalierung Jede Ästhetik hat zunächst eine Standard-Skalierung. Diese können Sie jedoch manuell anpassen 2.4.1 Axen-Skalierung: Wenn Datenpunkte sehr stark in einem kleinen Bereich der Grafik konzentriert sind, kann eine logarithmische Skalierung dabei helfen, diese Datenpunkte visuell zu entzerren. p + geom_point() + geom_smooth() + scale_y_log10() + scale_x_log10() 2.4.2 Farb-Skalierung Je nach Variablentyp eignen sich unterschiedliche Farbskalierungen: Nominal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = fahrzeugtyp)) + geom_point() + scale_color_brewer(type = &quot;qual&quot;, palette = &quot;Set1&quot;) Ordinal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = cut_interval(ps, n = 3))) + geom_point() + scale_color_brewer(type = &quot;seq&quot;, palette = &quot;Reds&quot;) Kardinal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = ps)) + geom_point() + scale_color_gradient(low = &quot;white&quot;, high = &quot;blue&quot;) Es gibt diverse vordefinierte Farbpaletten, siehe z.B. RColorBrewer::display.brewer.all()  alternativ können Farbskalierungen auch selbst definiert werden meine_palette &lt;- c(&quot;#4ecf71&quot;, &quot;#4e5dcf&quot;, &quot;#cf4ecf&quot;, &quot;#cf4e4e&quot;, &quot;#cfa44e&quot;) sample %&gt;% ggplot(aes(alter, preis, color = fahrzeugtyp)) + geom_point() + scale_color_manual(values = meine_palette) 2.5 Facetten Mehrdimensionale Plots sind oft überladen und schwer interpretierbar. Facettenplots sind dann eine hilfreiche Alternative. p &lt;- sample %&gt;% ggplot(aes(alter, preis)) + geom_point() p + facet_wrap(~fahrzeugtyp) p + facet_wrap(~ ps&gt;150) p + facet_grid(fahrzeugtyp ~ ps&gt;100) Hier können sie auch festlegen, dass jede Facette eine eigene Axenskalierung erhält p + facet_wrap(~fahrzeugtyp, scales = &quot;free&quot;) 2.6 Thema und Labels 2.6.1 Labels p + labs(x = &quot;Alter in Jahren&quot;, y = &quot;Preis in &quot;, title = &quot;Gebrauchtwagen&quot;) 2.6.2 Thema Sie können eines der unzähligen vordefinierten Themen verwenden p + theme_classic() p + ggthemes::theme_economist()  oder im Detail ihr eigenes Thema gestalten. p + theme(plot.background = element_rect(fill = &quot;lightgrey&quot;), panel.background = element_rect(fill = &quot;darkgrey&quot;), panel.border = element_rect(size = 2), panel.grid = element_line(linetype = 2), axis.title = element_text(size = 14)) "],["aggregierte-daten.html", "3 Aggregierte Daten 3.1 Sortierung 3.2 Überlappungen 3.3 Zwei kategoriale Variablen", " 3 Aggregierte Daten Das Thema Visualisierung von aggregierten Daten erschließen wir uns erneut anhand von Daten zu Gebrauchtwagenangeboten über Ebay Kleinanzeigen. library(tidyverse) theme_set(theme_bw()) df &lt;- read_csv(&quot;data/gebrauchtwagen.csv&quot;) glimpse(df) ## Rows: 20,000 ## Columns: 13 ## $ name &lt;chr&gt; &quot;smart_forTwo_Softtouch__passion_Inspektion_fuer_687_Euro_~ ## $ preis &lt;dbl&gt; 5299, 1100, 8199, 8999, 3600, 2490, 15500, 2700, 6200, 279~ ## $ alter &lt;dbl&gt; 7, 16, 14, 8, 13, 11, 7, 12, 8, 8, 22, 8, 9, 15, 16, 18, 1~ ## $ kilometer &lt;dbl&gt; 30000, 125000, 150000, 150000, 150000, 150000, 150000, 900~ ## $ hersteller &lt;chr&gt; &quot;smart&quot;, &quot;renault&quot;, &quot;audi&quot;, &quot;mercedes_benz&quot;, &quot;bmw&quot;, &quot;peuge~ ## $ modell &lt;chr&gt; &quot;fortwo&quot;, &quot;clio&quot;, &quot;a4&quot;, &quot;c_klasse&quot;, &quot;3er&quot;, &quot;1_reihe&quot;, &quot;5er~ ## $ fahrzeugtyp &lt;chr&gt; &quot;kleinwagen&quot;, &quot;kleinwagen&quot;, &quot;kombi&quot;, &quot;limousine&quot;, &quot;limousi~ ## $ getriebe &lt;chr&gt; &quot;automatik&quot;, &quot;manuell&quot;, &quot;automatik&quot;, &quot;automatik&quot;, &quot;manuell~ ## $ ps &lt;dbl&gt; 71, 75, 131, 136, 116, 68, 177, 69, 125, 67, 115, 121, 129~ ## $ kraftstoff &lt;chr&gt; &quot;benzin&quot;, &quot;benzin&quot;, &quot;benzin&quot;, &quot;diesel&quot;, &quot;benzin&quot;, &quot;diesel&quot;~ ## $ schaden &lt;chr&gt; &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;j~ ## $ plz &lt;dbl&gt; 35315, 36137, 85057, 10627, 65934, 14793, 28816, 30880, 71~ ## $ bundesland &lt;chr&gt; &quot;Hessen&quot;, &quot;Hessen&quot;, &quot;Bayern&quot;, &quot;Berlin&quot;, &quot;Hessen&quot;, &quot;Branden~ Bis hierhin haben wir hauptsächlich Rohdaten visualisiert. Nun wollen wir hingegen die Rohdaten auf eine höhere Ebene aggregieren und diese Ergebnisse visualisieren, z.B: Anzahl Autos je Fahrzeugtyp (SUV, Cabrio, Kleinwagen, etc) Durchschnittlicher Preis je Hersteller data &lt;- df %&gt;% group_by(fahrzeugtyp) %&gt;% summarise(n = n(), preis = mean(preis)) data ## # A tibble: 5 x 3 ## fahrzeugtyp n preis ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 cabrio 1639 8342. ## 2 kleinwagen 5418 3288. ## 3 kombi 4938 6130. ## 4 limousine 6974 5971. ## 5 suv 1031 11800. Der wichtigste Grafiktyp für diese Art von Daten ist das Balkendiagramm (Bar chart), welches wir über das geometrische Object geom_col erezugen können. data %&gt;% ggplot(aes(x = fahrzeugtyp, y = n)) + geom_col() Eine praktische Alternative zu geom_col ist geom_bar, jedoch noch für den Fall, dass die Anzahl der Beobachtungen dargestellt werden soll. Die Funktion geom_bar kann direkt auf die Rohdaten angewendet werden. Hierbei wird das Zählen der Fälle implizit durch die Funktion ausgeführt und muss nicht explizit per Code berechnet werden. df %&gt;% ggplot(aes(x = fahrzeugtyp)) + geom_bar() 3.1 Sortierung Ein typisches Problem ist, dass eine Text-Variable (character) wie fahrzeugtyp zunächst einmal nur alfabetisch sortiert werden kann. Für eine bessere Interpretierbarkeit ist es jedoch meistens sinnvoll, die Balken sortiert nach ihrer Höhe anzuordnen. Dafür müssen wie die Text-Variable in eine sogenannte Faktor-Variable (factor) umwandenln. Faktoren lassen sich nach unterschiedlichsten Kriterien sortieren, bspw. über die Funktion fct_reorder. data %&gt;% ggplot(aes(x = fct_reorder(fahrzeugtyp, -preis), y = preis)) + geom_col() 3.2 Überlappungen Eine weitere typische Schwierigkeit besteht in sich überlappenden Labels. Dieses Problem tritt insbesondere auf der x-Achse auf. Deshalb lohnt es sich, die Achsenzuordnung zu ändern und so ein horizontales Balkendiagramm zu erzeugen. # Map to y axis data &lt;- df %&gt;% group_by(bundesland) %&gt;% summarise(n = n(), preis = mean(preis)) data %&gt;% ggplot(aes(x = bundesland, y = preis)) + geom_col() data %&gt;% ggplot(aes(y = bundesland, x = preis)) + geom_col() Eine weitere Möglichkeit besteht darin, mehrere kleinere Balken zu einem großen Balken für Sonstige zusammenzufassen. df %&gt;% ggplot(aes(y = fct_lump(bundesland, n= 5))) + geom_bar() 3.3 Zwei kategoriale Variablen Wenn wir die aggregierten Statistiken nicht für eine sondern zwei kategorielle Variablen berechnen (bspw. für bundesland und fahrzeugtyp), gibt es mehrere denkbare Darstellungsformen. Eine Heatmap via geom_tile eignet sich insbesondere, wenn die kategorialen Variablen viele Ausprägungen haben, so wie es hier der Fall ist. df %&gt;% count(bundesland, fahrzeugtyp) %&gt;% ggplot() + geom_tile(aes(x = fahrzeugtyp, y = bundesland, fill = n), color = &quot;white&quot;) + geom_text(aes(x = fahrzeugtyp, y = bundesland, label = n), size = 3) + scale_fill_binned(low = &quot;white&quot;, high = &quot;red&quot;) Facetten-Plots können grundsätzlich auch für solche Fälle helfen. Im hier vorliegenden Fall, mit vielen Ausprägungen wird ein Facettenplot aber schnell unübersichtlich. df %&gt;% count(bundesland, fahrzeugtyp) %&gt;% ggplot() + geom_col(aes(y = fahrzeugtyp, x = n)) + facet_wrap(~bundesland, scales = &quot;free&quot;) "],["geodaten.html", "4 Geodaten 4.1 Simple Features 4.2 Ästhetiken 4.3 Schichten 4.4 Aggregation 4.5 Koordinatensystem", " 4 Geodaten Das Thema Visualisierung von Geodaten erschließen wir uns anhand von Daten der Weltbank aus der Reihe der World Development Indicators. Enthalten sind in den Daten alle Länder der Erde und ausgewählte Indikatoren seit 1990. Da die Zeitkomponente für das Verständnis nicht relevant ist, beschränken wir uns in der Folge auf das Jahr 2018 (für 2019 und 2020 fehlen noch viele Werte, daher wurden diese nicht berücksichtigt.) library(tidyverse) library(sf) theme_set( theme_bw() + theme(panel.background = element_blank(), panel.spacing = unit(0, &quot;lines&quot;), plot.background = element_blank(), legend.justification = c(0, 0), legend.position = c(0, 0), legend.background = element_blank()) ) 4.1 Simple Features wdi &lt;- read_csv(&quot;data/wdi.csv&quot;) # Einlesen der World Development Indicators wdi &lt;- wdi %&gt;% filter(jahr==2018) # Einschränkung auf das aktuellste Jahr im geo &lt;- read_rds(&quot;data/geo_wdi.rds&quot;) # Einlesen der Geodaten # Geodaten werden per Join zum Datensatz hinzugefügt df &lt;- wdi %&gt;% right_join(geo, by = &quot;iso2c&quot;) %&gt;% st_as_sf() glimpse(df) ## Rows: 213 ## Columns: 25 ## $ iso2c &lt;chr&gt; &quot;AD&quot;, &quot;AE&quot;, &quot;AF&quot;, &quot;AG&quot;, &quot;AL&quot;, &quot;AM&quot;, &quot;AO&quot;, &quot;AR~ ## $ land &lt;chr&gt; &quot;Andorra&quot;, &quot;United Arab Emirates&quot;, &quot;Afghanist~ ## $ kontinent &lt;chr&gt; &quot;Europe&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;North America&quot;, &quot;E~ ## $ subregion &lt;chr&gt; &quot;Southern Europe&quot;, &quot;Western Asia&quot;, &quot;Southern ~ ## $ jahr &lt;dbl&gt; 2018, 2018, 2018, 2018, 2018, 2018, 2018, 201~ ## $ bevölkerung &lt;dbl&gt; 77006, 9630959, 37172386, 96286, 2866376, 295~ ## $ bevölkerung_weiblich &lt;dbl&gt; NA, 30.63669, 48.63585, 51.78850, 49.06309, 5~ ## $ bevölkerung_0_14 &lt;dbl&gt; NA, 14.60351, 43.09018, 22.08109, 17.67287, 2~ ## $ `bevölkerung_65+` &lt;dbl&gt; NA, 1.085001, 2.584927, 8.799826, 13.744736, ~ ## $ bevölkerung_land &lt;dbl&gt; 11.938, 13.478, 74.505, 75.401, 39.681, 36.85~ ## $ bevölkerung_stadt &lt;dbl&gt; 88.062, 86.522, 25.495, 24.599, 60.319, 63.14~ ## $ `bevölkerung_unter$5.50` &lt;dbl&gt; NA, 0.1, NA, NA, NA, 42.5, 88.5, 12.3, NA, 1.~ ## $ bruttosozialprodukt &lt;dbl&gt; 3.218316e+09, 4.222150e+11, 1.835388e+10, 1.6~ ## $ fläche &lt;dbl&gt; 470.0, 98647.9, 652860.0, 440.0, 28750.0, 297~ ## $ lebenserwartung &lt;dbl&gt; NA, 77.81400, 64.48600, 76.88500, 78.45800, 7~ ## $ lebenserwartung_mann &lt;dbl&gt; NA, 77.133, 63.047, 75.721, 76.816, 71.215, 5~ ## $ lebenserwartung_frau &lt;dbl&gt; NA, 79.164, 66.026, 77.983, 80.167, 78.354, 6~ ## $ kindersterblichkeit &lt;dbl&gt; 2.9, 6.5, 48.0, 6.0, 8.5, 11.0, 51.9, 8.7, NA~ ## $ geburtenrate &lt;dbl&gt; NA, 1.413, 4.473, 1.994, 1.617, 1.755, 5.519,~ ## $ co2_emissionen &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ literacy_rate &lt;dbl&gt; NA, NA, 43.01972, NA, 98.14115, NA, NA, 99.00~ ## $ militärausgaben &lt;dbl&gt; NA, NA, 198074729, NA, 175886689, 608854650, ~ ## $ mordrate &lt;dbl&gt; NA, NA, 6.6555612, NA, 2.2894924, 1.6939156, ~ ## $ iso3c &lt;chr&gt; &quot;AND&quot;, &quot;ARE&quot;, &quot;AFG&quot;, &quot;ATG&quot;, &quot;ALB&quot;, &quot;ARM&quot;, &quot;AG~ ## $ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((1.706055 42..., ~ Es handelt sich nicht um einen gewöhnlichen R Datensatz (data frame), sondern um einen sogenannten Simple Feature Datensatz. Das besondere daran ist die Variable geometry, welche die Koordinaten (Längengrad und Breitengrad) der Ländergrenzen enthält. Analog zum bisherigen Vorgehen, benötigen wir für die Visualisierung einer Weltkarte nur 3 Dinge: (1) den (Simple Feature) Datensatz, (2) eine Ästhetikzuordnung (die Variable geometry wird der Ästhetik geometry zugeordet, und (3) den passenden Objecttyp geom_sf. Tatsächlich können wir hier die Ästhetikzuordnung sogar weglassen, die Spezifikation des Datensatzes und geom_sf ist hier sogar ausreichend. ggplot(df) + geom_sf() Was bedeutet der Begriff feature? Ein Feature kann grundsätzlich alles mögliche sein (Land, Fluss, Bushaltestelle), in unserem Fall ist es ein Land. Features können durch unterschiedliche Geometrien repräsentiert werden: eine Bushaltestelle durch einen Punkt, ein Fluss durch eine Linie, ein Land durch ein Polygon oder Multipolygon. Beispielsweise kann das Vereinigte Königreich nur durch einen Multipolygon repräsentiert werden, da es aus zwei Inseln (jeweils Polygone) besteht. uk &lt;- df %&gt;% filter(land == &quot;United Kingdom&quot;) ggplot(uk) + geom_sf() uk[[&quot;geometry&quot;]][[1]][[1]] # Dies sind die Koordinaten von Irland ## [[1]] ## [,1] [,2] ## [1,] -1.065576 50.69023 ## [2,] -1.149365 50.65571 ## [3,] -1.175830 50.61523 ## [4,] -1.196094 50.59922 ## [5,] -1.251465 50.58882 ## [6,] -1.306299 50.58853 ## [7,] -1.515332 50.66978 ## [8,] -1.563428 50.66611 ## [9,] -1.515674 50.70332 ## [10,] -1.385840 50.73354 ## [11,] -1.312793 50.77349 ## [12,] -1.144238 50.73472 ## [13,] -1.065576 50.69023 4.2 Ästhetiken Die wichtigste Ästhetik ist bei Karten in der Regel die Füllfarbe (fill). Wie bisher können sie sie entweder die Füllfarbe entweder auf eine bestimmte Ausprägung (bspw. red) fixieren, oder eine Variable des Datensatzes der Füllfarbe zuordnen (aesthetic mapping). Zu beachten: Die Farbe der Landesgrenzen können über color Ästhetik beeinflusst werden. map &lt;- df %&gt;% ggplot() map + geom_sf(aes(fill=kontinent)) # nominal-skalierte Variable map + geom_sf(aes(fill=lebenserwartung)) # kardinal-skalierte Variable 4.3 Schichten Wie bisher können Sie auch hier über zusätzliche geom_[typ] Funktionen weitere Schichten definieren. Dies ist auch hier insbesondere für Hervorhebungen hilfreich. auswahl &lt;- df %&gt;% filter(land %in% c(&quot;Germany&quot;, &quot;Brazil&quot;, &quot;China&quot;, &quot;South Africa&quot;)) map + geom_sf(aes(fill=kontinent)) + geom_sf_label(data = auswahl, aes(label=land)) 4.4 Aggregation In manchen Situationen möchten wir die Daten durch eine Aggregation verdichten, bspw. um die durchschnittliche Lebenserwartung je Kontinent zu berechnen. kontinente &lt;- df %&gt;% group_by(kontinent) %&gt;% summarise(lebenserwartung = mean(lebenserwartung, na.rm=TRUE)) kontinente ## Simple feature collection with 8 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -55.8917 xmax: 180 ymax: 83.59961 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## # A tibble: 8 x 3 ## kontinent lebenserwartung geometry ## &lt;chr&gt; &lt;dbl&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 Africa 63.4 (((-2.938306 5.124495, -2.94834 5.118848, -3.~ ## 2 Asia 74.3 (((122.9489 -10.90928, 122.8559 -10.90967, 12~ ## 3 Europe 79.3 (((55.79736 -21.33936, 55.65615 -21.36904, 55~ ## 4 North America 76.0 (((-78.89834 8.274268, -78.91812 8.231934, -7~ ## 5 Oceania 73.4 (((158.8788 -54.70977, 158.8452 -54.74922, 15~ ## 6 Seven seas (op~ 75.3 (((57.65127 -20.48486, 57.5248 -20.51318, 57.~ ## 7 South America 74.9 (((-67.5752 -55.88965, -67.61143 -55.8917, -6~ ## 8 &lt;NA&gt; NaN (((23.38066 -17.64062, 23.59492 -17.59941, 23~ Die gute Nachricht: bei der Aggregation wird auch die geometry Variable so aktualisiert, dass diese nun die Umrisse der jeweiligen Kontinente repräsentiert. kontinente %&gt;% ggplot() + geom_sf(aes(fill = lebenserwartung), color = NA) 4.5 Koordinatensystem Bisher haben wir das Thema Koordinatensystem nicht explizit angesprochen. Im Kontext von Karten ist es aber besonders relevant, da unsere 3-dimensionale Erde nicht akurat in 2 Dimensionen dargestellt werden kann. Es stehen uns nun unterschiedlich Projektionen zu Verfügung, die jeweils vorgeben, wo die Längen- und Breitengrade in den zwei Dimensionn verortet werden. Betrachten wir nun folgende Basiskarte: (basiskarte &lt;- df %&gt;% ggplot() + geom_sf(aes(fill = kontinent), color=NA) + scale_fill_brewer(palette = &quot;Set1&quot;, na.value = &quot;grey&quot;)) Die Mercator Projection stellt Formen und Winkel korrekt dar, aber in Richtung der Pole wird die Größe der Länder künstlich aufgebläht. basiskarte + coord_sf(crs = st_crs(&quot;+proj=merc&quot;)) Hingegen werden bei der Lambert Azimuthal Equal Area (LAEA) Projektion die Ländergrößen korrekt dargestellt, wobei aber eine Verzerrung der Formen und Winkel in Kauf genommen wird. Auch der Perspektivwechsel auf einen anderen Mittelpunkt (hier Lhasa, Tibet) kann einen Mehrwert bzgl. der Interpretation schaffen. basiskarte + coord_sf(crs = st_crs(&quot;+proj=laea + lat_0=29.6490404 + lon_0=91.0052352&quot;)) "],["zeit.html", "5 Zeit", " 5 Zeit Das Thema Zeitbezug erschließen wir uns anhand von Daten zu Luft-Schadstoffmessungen an ausgewählten Standorten in Deutschland seit 2006. Ausgewählt wurden neben zwei Kieler Standorten 6 Standorte mit überwiegend hohen Werten (für unterschiedliche Schadstofftypen). Zu beachten ist, dass im Datensatz auch eine große Anzahl an fehlender Werte (NA) enthalten sind. library(tidyverse) library(sf) df &lt;- read_csv(&quot;data/schadstoffe-zeitreihen.csv&quot;) glimpse(df) ## Rows: 39,001 ## Columns: 14 ## $ standort_id &lt;chr&gt; &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115~ ## $ standort &lt;chr&gt; &quot;München/Landshuter Allee&quot;, &quot;München/Landshuter Alle~ ## $ datum &lt;date&gt; 2006-01-01, 2006-01-02, 2006-01-03, 2006-01-04, 200~ ## $ kohlenmonoxid &lt;dbl&gt; 0.9445625, 1.1983400, 0.9279800, 0.6893000, 0.676340~ ## $ stickstoffmonoxid &lt;dbl&gt; 90.25696, 141.18668, 116.77000, 58.74500, 53.13500, ~ ## $ stickstoffdioxid &lt;dbl&gt; 99.14758, 80.95000, 79.06500, 57.35332, 50.00500, 53~ ## $ stickoxide &lt;dbl&gt; 237.2274, 297.2742, 258.1775, 147.5283, 131.4792, 10~ ## $ feinstaub10 &lt;dbl&gt; 59.47917, 38.29084, 29.28584, 21.94332, 27.47916, 34~ ## $ feinstaub2.5 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ ozon &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ schwefeldioxid &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ typ &lt;chr&gt; &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic~ ## $ gebiet &lt;chr&gt; &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;~ ## $ hoehe &lt;dbl&gt; 521, 521, 521, 521, 521, 521, 521, 521, 521, 521, 52~ Der Zeit-Aspekt bringt einige Besonderheiten mit sich. Unter anderem wollen wir prüfen, ob die Entwicklung von Luftqualitätsmessungen einem bestimmten Saisonalen (oder anderartigem) Muster unterliegt. Dafür extrahieren wir aus der Datumsvariable zunächst zusätzliche Informationen. df &lt;- df %&gt;% mutate(jahr = lubridate::year(datum), tagimjahr = lubridate::yday(datum), monat = lubridate::month(datum, label=TRUE, abbr = TRUE), wochentag = lubridate::wday(datum, label=TRUE, abbr = TRUE)) Das besondere an den Variablen monat und wochentag ist, dass es sich hierbei um ordinal-skalierte Variablen handelt (ordered factors). Dies hat den Vorteil, dass sie sprechend als Januar, Februar, etc. dargestellt werden, sie aber der natürlichen Sortierung unterliegen. Überprüfen lässt sich der Variablentyp wie folgt: class(df$monat) ## [1] &quot;ordered&quot; &quot;factor&quot; Zunächst fokussieren wir uns auf die Besonderheiten bzgl. der Visualisierung einer einzelnen Zeitreihe. Dazu beschränkten wir den Zeitreihen-Datensatz auf einen Standort. muenchen &lt;- df %&gt;% dplyr::filter(standort == &quot;München/Landshuter Allee&quot;) Es stellt sich die Frage nach einem geeigneten geometrischen Objekt (geometric object). Grundsätzlich eignen sich Liniendiagramme (geom_line) gut für Zeitreihen. Aufgrund der hier vorliegenden starken Schwankungen kann es aber Sinn machen, die einzelnen Messpunkte (geom_point) darzustellen. Um den langfristigen Trend zu verdeutlichen eignet sich eine geglättete Trendlinie (geom_smooth). p &lt;- muenchen %&gt;% ggplot(aes(datum, stickstoffdioxid)) p + geom_line() p + geom_point() p + geom_line() + geom_smooth() Es lässt sich bereits erahnen, dass im vorliegenden Fall die Schwankungen einem bestimmten Muster mit Zeitbezug folgen. Schauen wir uns ein einzelnes Jahr konkreter an. Bei stickstoffdioxid scheint im Jahr 2019 kein klares saisonales Muster vorzuliegen. Wir können an diesem Beispiel aber demonstrieren, wie sich die Datum-Labels und die Gitterlinien anpassen lassen. Die unzähligen Formatierungsoptionen für Datums-Labels können via help(strftime) nachfollzogen werden. p &lt;- muenchen %&gt;% filter(jahr==2019) %&gt;% ggplot(aes(datum, stickstoffdioxid)) + geom_line() + geom_smooth() p + scale_x_date(date_labels = &#39;%D&#39;) p + scale_x_date(date_labels = &#39;%a, %d. %B %y&#39;, date_breaks = &quot;4 months&quot;, date_minor_breaks = &quot;1 months&quot;) Um nachzuvollziehen, ob sich ein bestimmtes saisonales Muster nur in einem Jahr zeigt, oder in allen Jahren, können wir die Variable jahr der Ästhetik Farbe zuordnen. Das funktioniert allerdings nur, wenn sie die numerische Variable jahr in eine kategoriale Variable (factor) umwandeln. Speziell geeignet ist hier wieder die Ordinal-Skalierung (ordered). muenchen %&gt;% ggplot(aes(tagimjahr, stickstoffdioxid, color = ordered(jahr))) + geom_smooth(se=FALSE) Um den Tag im Jahr sprechender zu gestalten, bedienen wir uns eines Tricks: muenchen %&gt;% mutate(datum0 = as.Date(&quot;1970-01-01&quot;) + tagimjahr) %&gt;% ggplot(aes(datum0, feinstaub10, color = ordered(jahr)))+ geom_smooth(se=FALSE) + scale_x_date(date_labels = &quot;%B&quot;) "]]
