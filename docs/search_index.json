[["index.html", "Einführung in die Datenvisualisierung mit R IDW Workshop 1 R und RStudio 1.1 Erste Schritte 1.2 Datenmanipulation", " Einführung in die Datenvisualisierung mit R IDW Workshop Prof. Dr. Tillmann Schwörer, FH Kiel, Studiengang Data Science 2021-05-04 1 R und RStudio An dieser Stelle stichpunktartig ein paar zentrale Informationen zum Arbeiten mit R und RStudio. 1.1 Erste Schritte R ist eine Software für statistische Berechnungen und Grafiken. RStudio ist eine integrierte Entwicklungsumgebung (IDE) für R. Wir werden in diesem Kurs ausschließlich über RStudio mit R arbeiten (wobei dies bspw. auch über die Kommandozeile, Jupyter Notebooks, oder andere IDEs möglich ist) Die Funktionalität der Basisinstallation lässt sich über R Pakete in jede denkbare Richtung erweitern (Datenaufbereitung, Visualisierung, Maschinelles Lernen, ). Pakete können von jedermann geschrieben werden und über Plattformen wie CRAN oder Github der Allgemeinheit zur Verfügung gestellt werden. Pakete müssen grundsätzlich nur 1 mal installiert werden, wobei ein gelegentliches Update Sinn macht. Jedes Mal, wenn die Funktionalität des Paketes in ein R Skript einebunden werden soll, muss das Paket über den library Befehl geladen werden. Dieser Kurs nutzt insbesondere das R Paket tidyverse. Genauer gesagt handelt es sich dabei um eine Sammlung mehrerer Pakete. Enthalten ist darin insbesondere das Paket ggplot2, welches wir für die Visualisierungen verwendet werden. An dieser Stelle auch der Hinweis, dass sich die Syntax des tidyverse teilweise deutlich von base R Syntax unterscheidet. Programmcode kann einerseits in R Skripten (Dateiendung: .R) und R Markdown Dateien (.Rmd) geschrieben werden. Erstere eignen sich insbesondere, wenn der Programmcode im Vordergrund steht. Letztere eignen sich insbesondere, wenn auch Erläuterungen und die Präsentation von Ergebnissen wichtig sind. 1.2 Datenmanipulation Die wichtigsten Operationen zur Datenmanipulation werden nun ganz kurz angerissen: Zu Beginn der R Dateien sind die benötigten Pakete einzubinden. library(tidyverse) ## Warning: Paket &#39;tidyverse&#39; wurde unter R Version 4.0.5 erstellt ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.3 v purrr 0.3.4 ## v tibble 3.1.0 v dplyr 1.0.5 ## v tidyr 1.1.3 v stringr 1.4.0 ## v readr 1.4.0 v forcats 0.5.1 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Die Funktion read_rds ist teil des Paketes tidyverse. Das heißt, sie können die Funktion nur verwenden, wenn sie vorher das Paket geladen haben. In den meisten Fällen werden wir Daten von Komma-separierte Datein (.csv) einlesen. Gelegentich werden wir auch Dateien mit dem R spezifischen Typ .rds einlesen.Der Pfeil Operator &lt;- verwenden wir, um ein bestimmtes Object (hier: ein Datensatz) einem Namen (hier: df) zuzordnen. Nun taucht der Datensatz unter diesem Namen im Environment Tab von RStudio auf. df &lt;- read_csv(&quot;data/wdi.csv&quot;) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_double(), ## iso2c = col_character(), ## land = col_character(), ## kontinent = col_character(), ## subregion = col_character() ## ) ## i Use `spec()` for the full column specifications. Einen schnellen Überblick über einen Datensatz können wir uns mithilfe der folgenden Funktionen verschaffen: head(df) # Erste 6 Zeilen ## # A tibble: 6 x 23 ## iso2c land kontinent subregion jahr bevölkerung bevölkerung_weiblich ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AD Andorra Europe Southern Europe 1990 54509 NA ## 2 AD Andorra Europe Southern Europe 1991 56671 NA ## 3 AD Andorra Europe Southern Europe 1992 58888 NA ## 4 AD Andorra Europe Southern Europe 1993 60971 NA ## 5 AD Andorra Europe Southern Europe 1994 62677 NA ## 6 AD Andorra Europe Southern Europe 1995 63850 NA ## # ... with 16 more variables: bevölkerung_0_14 &lt;dbl&gt;, bevölkerung_65+ &lt;dbl&gt;, ## # bevölkerung_land &lt;dbl&gt;, bevölkerung_stadt &lt;dbl&gt;, ## # bevölkerung_unter$5.50 &lt;dbl&gt;, bruttosozialprodukt &lt;dbl&gt;, fläche &lt;dbl&gt;, ## # lebenserwartung &lt;dbl&gt;, lebenserwartung_mann &lt;dbl&gt;, ## # lebenserwartung_frau &lt;dbl&gt;, kindersterblichkeit &lt;dbl&gt;, geburtenrate &lt;dbl&gt;, ## # co2_emissionen &lt;dbl&gt;, literacy_rate &lt;dbl&gt;, militärausgaben &lt;dbl&gt;, ## # mordrate &lt;dbl&gt; glimpse(df) # Kurzvorschau jeder Variable mit einigen Metadaten ## Rows: 6,177 ## Columns: 23 ## $ iso2c &lt;chr&gt; &quot;AD&quot;, &quot;AD&quot;, &quot;AD&quot;, &quot;AD&quot;, &quot;AD&quot;, &quot;AD&quot;, &quot;AD&quot;, &quot;AD~ ## $ land &lt;chr&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;~ ## $ kontinent &lt;chr&gt; &quot;Europe&quot;, &quot;Europe&quot;, &quot;Europe&quot;, &quot;Europe&quot;, &quot;Euro~ ## $ subregion &lt;chr&gt; &quot;Southern Europe&quot;, &quot;Southern Europe&quot;, &quot;Southe~ ## $ jahr &lt;dbl&gt; 1990, 1991, 1992, 1993, 1994, 1995, 1996, 199~ ## $ bevölkerung &lt;dbl&gt; 54509, 56671, 58888, 60971, 62677, 63850, 643~ ## $ bevölkerung_weiblich &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ bevölkerung_0_14 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ `bevölkerung_65+` &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ bevölkerung_land &lt;dbl&gt; 5.288, 5.470, 5.676, 5.889, 6.110, 6.339, 6.5~ ## $ bevölkerung_stadt &lt;dbl&gt; 94.712, 94.530, 94.324, 94.111, 93.890, 93.66~ ## $ `bevölkerung_unter$5.50` &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ bruttosozialprodukt &lt;dbl&gt; 1029048482, 1106928583, 1210013652, 100702575~ ## $ fläche &lt;dbl&gt; 470, 470, 470, 470, 470, 470, 470, 470, 470, ~ ## $ lebenserwartung &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ lebenserwartung_mann &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ lebenserwartung_frau &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ kindersterblichkeit &lt;dbl&gt; 9.1, 8.8, 8.6, 8.4, 8.2, 7.9, 7.7, 7.4, 7.1, ~ ## $ geburtenrate &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ co2_emissionen &lt;dbl&gt; 407.037, 407.037, 407.037, 410.704, 407.037, ~ ## $ literacy_rate &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ militärausgaben &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ mordrate &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ Wenn wir genauere Information zu einer R Funktion oder einem Paket benötigen können wir die Hilfe verwenden, z.B. help(head). Wir verwenden die filter Funktion, um eine Teilmenge der Zeilen zu selektieren. Hier wählen wir alle Zeilen, für die Variable jahr den Wert 2018 annimmt und die Variale bevölkerung größer als 200 Millionen ist. filter(df, jahr==2018 &amp; bevölkerung&gt;200000000) ## # A tibble: 6 x 23 ## iso2c land kontinent subregion jahr bevölkerung bevölkerung_weib~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BR Brazil South Amer~ South America 2018 209469333 50.8 ## 2 CN China Asia Eastern Asia 2018 1392730000 48.7 ## 3 ID Indonesia Asia South-Eastern~ 2018 267663435 49.6 ## 4 IN India Asia Southern Asia 2018 1352617328 48.0 ## 5 PK Pakistan Asia Southern Asia 2018 212215030 48.5 ## 6 US United S~ North Amer~ Northern Amer~ 2018 326687501 50.5 ## # ... with 16 more variables: bevölkerung_0_14 &lt;dbl&gt;, bevölkerung_65+ &lt;dbl&gt;, ## # bevölkerung_land &lt;dbl&gt;, bevölkerung_stadt &lt;dbl&gt;, ## # bevölkerung_unter$5.50 &lt;dbl&gt;, bruttosozialprodukt &lt;dbl&gt;, fläche &lt;dbl&gt;, ## # lebenserwartung &lt;dbl&gt;, lebenserwartung_mann &lt;dbl&gt;, ## # lebenserwartung_frau &lt;dbl&gt;, kindersterblichkeit &lt;dbl&gt;, geburtenrate &lt;dbl&gt;, ## # co2_emissionen &lt;dbl&gt;, literacy_rate &lt;dbl&gt;, militärausgaben &lt;dbl&gt;, ## # mordrate &lt;dbl&gt; Alternativ können wir dies unter Verwendung des sog. Pipe Operators (%&gt;%) wie folgt schreiben. df %&gt;% filter(jahr==2018 &amp; bevölkerung&gt;200000000) ## # A tibble: 6 x 23 ## iso2c land kontinent subregion jahr bevölkerung bevölkerung_weib~ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BR Brazil South Amer~ South America 2018 209469333 50.8 ## 2 CN China Asia Eastern Asia 2018 1392730000 48.7 ## 3 ID Indonesia Asia South-Eastern~ 2018 267663435 49.6 ## 4 IN India Asia Southern Asia 2018 1352617328 48.0 ## 5 PK Pakistan Asia Southern Asia 2018 212215030 48.5 ## 6 US United S~ North Amer~ Northern Amer~ 2018 326687501 50.5 ## # ... with 16 more variables: bevölkerung_0_14 &lt;dbl&gt;, bevölkerung_65+ &lt;dbl&gt;, ## # bevölkerung_land &lt;dbl&gt;, bevölkerung_stadt &lt;dbl&gt;, ## # bevölkerung_unter$5.50 &lt;dbl&gt;, bruttosozialprodukt &lt;dbl&gt;, fläche &lt;dbl&gt;, ## # lebenserwartung &lt;dbl&gt;, lebenserwartung_mann &lt;dbl&gt;, ## # lebenserwartung_frau &lt;dbl&gt;, kindersterblichkeit &lt;dbl&gt;, geburtenrate &lt;dbl&gt;, ## # co2_emissionen &lt;dbl&gt;, literacy_rate &lt;dbl&gt;, militärausgaben &lt;dbl&gt;, ## # mordrate &lt;dbl&gt; Der Vorteil davon ist hier noch nicht ersichtlich, sondern erst, wenn wir mehrere Verarbeiungsschritte miteinander verketten, bspw. durch Selektion einzelner Spalten (select) und Sortierung (arrange). Der Vorteil besteht darin, dass wir nicht nach jeder Operation ein Zwischenergebnis speichern müssen. df %&gt;% filter(jahr==2018 &amp; bevölkerung&gt;200000000) %&gt;% # Selektion einzelner Zeilen select(land, kontinent, bevölkerung) %&gt;% # Selektion einzelner Spalten arrange(-bevölkerung) # Sortieren anhand der Spalte Bevölkerung ## # A tibble: 6 x 3 ## land kontinent bevölkerung ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 China Asia 1392730000 ## 2 India Asia 1352617328 ## 3 United States North America 326687501 ## 4 Indonesia Asia 267663435 ## 5 Pakistan Asia 212215030 ## 6 Brazil South America 209469333 Mithilfe der Funktion mutate können wir neue Variablen erstellen, oder alte überschreiben. df %&gt;% select(land, bevölkerung, bruttosozialprodukt) %&gt;% mutate(pro_kopf_einkommen = bruttosozialprodukt / bevölkerung) %&gt;% head(1) ## # A tibble: 1 x 4 ## land bevölkerung bruttosozialprodukt pro_kopf_einkommen ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Andorra 54509 1029048482. 18879. Mithilfe der Funktion summarise können wir unterschiedliche aggregierte Statistiken berechnen. Unter help(summarise) können sie wichtige Funktionen sehen, die zur Verfügung stehen. Zu beachten ist die Behandlung von fehlenden Werten (NA, not available). Um trotz vorhandener fehlender Werte ein Ergebnis angezeigt zu bekommen, muss die Option na.rm (remove NAs) auf TRUE gesetzt werden. df %&gt;% summarise(welt_gesamtbevölkerung = sum(bevölkerung, na.rm=TRUE), durchschnittliche_bevölkerung = mean(bevölkerung, na.rm=TRUE), max_bevölkerung = max(bevölkerung, na.rm=TRUE)) ## # A tibble: 1 x 3 ## welt_gesamtbevölkerung durchschnittliche_bevölkerung max_bevölkerung ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 185924258270. 30187410. 1392730000 Häufig kombinieren wir summarise mit der Funktion group_by. Dann wird die Berechnung nicht für den gesamten Datensatz ausgeführt, sondern separat für jede durch group_by definierte Gruppe. df %&gt;% group_by(kontinent) %&gt;% summarise(sum(bevölkerung, na.rm=TRUE)) ## # A tibble: 7 x 2 ## kontinent `sum(bevölkerung, na.rm = TRUE)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Africa 26463948892 ## 2 Asia 112029446576. ## 3 Europe 21168009976 ## 4 North America 14678984242 ## 5 Oceania 981192777 ## 6 Seven seas (open ocean) 46714086 ## 7 South America 10555961721 "],["ggplot2.html", "2 ggplot2 2.1 Grundlagen 2.2 Ästhetik-Zuordnung 2.3 Geometrisches Objekt 2.4 Skalierung 2.5 Facetten 2.6 Thema und Labels", " 2 ggplot2 Die Einführung in die Bibliothek ggplot2 vollziehen wir anhand von: Daten zu Gebrauchtwagen, die über Ebay-Kleinanzeigen verkauft wurden. Die hier verwendeten Daten stellen einen Ausschnitt aus einem noch größeren Datensatz dar, der über die Plattform Kaggle erhältlich ist. Im Vergleich zu den Originaldaten wurden extreme Ausreißer eliminiert und Variablen umbenannt. Streudiagrammen (scatterplots). Wir verwenden diese um die Beziehung zwischen 2 oder mehr Variablen zu visualisieren. library(tidyverse) theme_set(theme_bw()) # Standard Thema (Hintergrund, etc.) für die Grafiken df &lt;- read_csv(&quot;data/gebrauchtwagen.csv&quot;) # Daten einlesen sample &lt;- df %&gt;% slice(1:500) # Kleiner Datensatz, der die ersten 500 Zeilen umfasst glimpse(sample) ## Rows: 500 ## Columns: 13 ## $ name &lt;chr&gt; &quot;smart_forTwo_Softtouch__passion_Inspektion_fuer_687_Euro_~ ## $ preis &lt;dbl&gt; 5299, 1100, 8199, 8999, 3600, 2490, 15500, 2700, 6200, 279~ ## $ alter &lt;dbl&gt; 7, 16, 14, 8, 13, 11, 7, 12, 8, 8, 22, 8, 9, 15, 16, 18, 1~ ## $ kilometer &lt;dbl&gt; 30000, 125000, 150000, 150000, 150000, 150000, 150000, 900~ ## $ hersteller &lt;chr&gt; &quot;smart&quot;, &quot;renault&quot;, &quot;audi&quot;, &quot;mercedes_benz&quot;, &quot;bmw&quot;, &quot;peuge~ ## $ modell &lt;chr&gt; &quot;fortwo&quot;, &quot;clio&quot;, &quot;a4&quot;, &quot;c_klasse&quot;, &quot;3er&quot;, &quot;1_reihe&quot;, &quot;5er~ ## $ fahrzeugtyp &lt;chr&gt; &quot;kleinwagen&quot;, &quot;kleinwagen&quot;, &quot;kombi&quot;, &quot;limousine&quot;, &quot;limousi~ ## $ getriebe &lt;chr&gt; &quot;automatik&quot;, &quot;manuell&quot;, &quot;automatik&quot;, &quot;automatik&quot;, &quot;manuell~ ## $ ps &lt;dbl&gt; 71, 75, 131, 136, 116, 68, 177, 69, 125, 67, 115, 121, 129~ ## $ kraftstoff &lt;chr&gt; &quot;benzin&quot;, &quot;benzin&quot;, &quot;benzin&quot;, &quot;diesel&quot;, &quot;benzin&quot;, &quot;diesel&quot;~ ## $ schaden &lt;chr&gt; &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;j~ ## $ plz &lt;dbl&gt; 35315, 36137, 85057, 10627, 65934, 14793, 28816, 30880, 71~ ## $ bundesland &lt;chr&gt; &quot;Hessen&quot;, &quot;Hessen&quot;, &quot;Bayern&quot;, &quot;Berlin&quot;, &quot;Hessen&quot;, &quot;Branden~ 2.1 Grundlagen Minimale Angaben zur Erstellung einer Grafik: Datensatz (data) Ästhetik-Zuordnung (aesthetic mapping): Welche Variable des Datensatzes wird durch welche Ästhetik (x-Achse, y-Achse, Farbe, Größe, Form, ) repräsentiert? Geometrisches Objekt (geometric object): z.B. Punkte, Linien, Balken, etc. ggplot(data = sample, mapping = aes(x = alter, y = preis)) + geom_point() Wie ändert sich die Grafik, wenn wir den vollen Datensatz (df) verwenden? ggplot(data = df, mapping = aes(x = alter, y = preis)) + geom_point() Wie ändert sich die Grafik, wenn wir eine andere Ästhetik-Zuordnung vornehmen? ggplot(data = sample, mapping = aes(x = preis, y = alter)) + geom_point() ggplot(data = sample, mapping = aes(x = preis, y = hersteller)) + geom_point() ggplot(data = sample, mapping = aes(x = fahrzeugtyp, y = hersteller)) + geom_point() Wie ändert sich die Grafik, wenn wir einen anderen Objekttyp wählen? ggplot(data = sample, mapping = aes(x = fahrzeugtyp, y = hersteller)) + geom_jitter(width = 0.1) ggplot(data = df, mapping = aes(x = alter, y = preis)) + geom_density2d_filled() 2.2 Ästhetik-Zuordnung Über weitere Ästhetik-Zuordnungen (Welche Variable wird durch welche Ästhetik repräsentiert?) können wir eine mehrdimensionale Visualisierung erstellen. Welche Ästhetiken für geom_point zur Verfügung stehen, kann man via help(geom_point) unter der Überschrift Aesthetics nachlesen. Je nach Varialentyp sind unterschiedliche Ästhetiken sinnvoll. 2.2.1 Kardinal-skalierte Variable Für kardinal-skalierte Variablen wie ps (für Pferdestärke) sind beispielsweise die Ästhetiken Farbe (color), Größe (size) und Transparenz (alpha) denkbar, wobei nur die Farbe richtig überzeugt. sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = ps)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, size = ps)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, alpha = ps)) + geom_point() 2.2.2 Nominal-skalierte Variable Für nominal-skalierte Variablen wie fahrzeugtyp eignen sich bspw. die Ästhetiken Farbe (color) und Form (shape). sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = fahrzeugtyp)) + geom_point() sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, shape = fahrzeugtyp)) + geom_point() 2.2.3 Fixierte Ästhetik Beachten Sie den Unterschied zwischen (1) einer Ästhetik-Zuordnung (aesthetic mapping) und (2) einer fest definierten Ästhetik! Im folgenden Beispiel werden die Ästhetiken Farbe (color), Transparenz (alpha), Größe (size) und Form (shape) auf konkrete Werte festgelegt. Das heißt für jeden dargestellten Datenpunkt wird dieselbe Farbe, Transparenz, etc. verwendet. Hingegen bekommen bei einer Ästhetik-Zuordnung die Datenpunkte unterschiedliche Farben, Transparenzen, etc. in Abhängigkeit vom Wert der jeweiligen Variable des Datensatzes. sample %&gt;% ggplot(mapping = aes(x = alter, y = preis)) + geom_point(color = &quot;#54b856&quot;, alpha = 0.5, size = 3, shape = 18) 2.3 Geometrisches Objekt Grundsätzlich stehen Ihnen eine große Auswahl an Objekttypen zur Verfügung. Aber: Für eine gegebene Fragestellung kommen idR nur wenige davon konkret in Frage. Betrachten wir, welche Objekttypen für die folgende Fragestellung sinnvoll sein könnten: Wie stehen Fahrzeugalter und Preis miteinander in Beziehung? p &lt;- sample %&gt;% ggplot(aes(x = alter, y = preis)) p + geom_point() p + geom_jitter() # zufälliges &quot;Zittern&quot; um Überlappungen zu reduzieren p + geom_smooth() # Geglättete Linie p + geom_density_2d() # Umrisse einer 2-dimensionalen Dichteschätzung Beachten Sie, dass die geom_[typ] Funktionen teilweise implizite Veränderungen an den Daten vornehmen: bspw. statistische Berechnungen (geom_smooth, geom_density_2d) oder Positionsanpassungen (geom_jitter). Diese standardmäßig verwendeten Verändungen können Sie aber auch manuell verhindern bzw. anpassen, bspw: p + geom_smooth(method = &quot;lm&quot;) # Lineare Regressionsgerade Sie können mithilfe der geom Funktionen auch mehrere Datenschichten übereinander legen. Dabei definiert jeder Objekttyp genau eine Schicht. Je Schicht können auch eigene Daten oder eine eigene Ästhetik-Zuordnung verwendet werden. Beispiel 1: Streudiagramm mit Smooth Line p + geom_point() + geom_smooth() Beipsiel 2: Hervorhebung einer Teilmenge der Daten subset &lt;- sample %&gt;% filter(hersteller == &quot;opel&quot;) p + geom_point(color = &quot;grey&quot;, alpha = 0.2) + geom_point(data = subset, aes(color = hersteller)) Beispiel 3: Labels für interessante Datenpunkte subset &lt;- sample %&gt;% filter(preis==max(preis) | alter==max(alter)) p + geom_point() + ggrepel::geom_label_repel(data = subset, mapping = aes(label = name), min.segment.length = 0.1) Beispiel 4: Streudiagramm mit mehreren Smooth Lines sample %&gt;% ggplot(mapping = aes(x = alter, y = preis, color = fahrzeugtyp)) + geom_point() + geom_smooth(se=FALSE) 2.4 Skalierung Jede Ästhetik hat zunächst eine Standard-Skalierung. Diese können Sie jedoch manuell anpassen 2.4.1 Axen-Skalierung: Wenn Datenpunkte sehr stark in einem kleinen Bereich der Grafik konzentriert sind, kann eine logarithmische Skalierung dabei helfen, diese Datenpunkte visuell zu entzerren. p + geom_point() + geom_smooth() + scale_y_log10() + scale_x_log10() 2.4.2 Farb-Skalierung Je nach Variablentyp eignen sich unterschiedliche Farbskalierungen: Nominal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = fahrzeugtyp)) + geom_point() + scale_color_brewer(type = &quot;qual&quot;, palette = &quot;Set1&quot;) Ordinal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = cut_interval(ps, n = 3))) + geom_point() + scale_color_brewer(type = &quot;seq&quot;, palette = &quot;Reds&quot;) Kardinal-skalierte Variable sample %&gt;% ggplot(aes(alter, preis, color = ps)) + geom_point() + scale_color_gradient(low = &quot;white&quot;, high = &quot;blue&quot;) Es gibt diverse vordefinierte Farbpaletten, siehe z.B. RColorBrewer::display.brewer.all()  alternativ können Farbskalierungen auch selbst definiert werden meine_palette &lt;- c(&quot;#4ecf71&quot;, &quot;#4e5dcf&quot;, &quot;#cf4ecf&quot;, &quot;#cf4e4e&quot;, &quot;#cfa44e&quot;) sample %&gt;% ggplot(aes(alter, preis, color = fahrzeugtyp)) + geom_point() + scale_color_manual(values = meine_palette) 2.5 Facetten Mehrdimensionale Plots sind oft überladen und schwer interpretierbar. Facettenplots sind dann eine hilfreiche Alternative. p &lt;- sample %&gt;% ggplot(aes(alter, preis)) + geom_point() p + facet_wrap(~fahrzeugtyp) p + facet_wrap(~ ps&gt;150) p + facet_grid(fahrzeugtyp ~ ps&gt;100) Hier können sie auch festlegen, dass jede Facette eine eigene Axenskalierung erhält p + facet_wrap(~fahrzeugtyp, scales = &quot;free&quot;) 2.6 Thema und Labels 2.6.1 Labels p + labs(x = &quot;Alter in Jahren&quot;, y = &quot;Preis in &quot;, title = &quot;Gebrauchtwagen&quot;) 2.6.2 Thema Sie können eines der unzähligen vordefinierten Themen verwenden p + theme_classic() p + ggthemes::theme_economist()  oder im Detail ihr eigenes Thema gestalten. p + theme(plot.background = element_rect(fill = &quot;lightgrey&quot;), panel.background = element_rect(fill = &quot;darkgrey&quot;), panel.border = element_rect(size = 2), panel.grid = element_line(linetype = 2), axis.title = element_text(size = 14)) "],["geodaten.html", "3 Geodaten 3.1 Simple Features 3.2 Ästhetiken 3.3 Schichten 3.4 Aggregation 3.5 Koordinatensystem", " 3 Geodaten Das Thema Visualisierung von Geodaten erschließen wir uns anhand von Daten der Weltbank aus der Reihe der World Development Indicators. Enthalten sind in den Daten alle Länder der Erde und ausgewählte Indikatoren seit 1990. Da die Zeitkomponente für das Verständnis nicht relevant ist, beschränken wir uns in der Folge auf das Jahr 2018 (für 2019 und 2020 fehlen noch viele Werte, daher wurden diese nicht berücksichtigt.) library(tidyverse) library(sf) theme_set( theme_bw() + theme(panel.background = element_blank(), panel.spacing = unit(0, &quot;lines&quot;), plot.background = element_blank(), legend.justification = c(0, 0), legend.position = c(0, 0), legend.background = element_blank()) ) 3.1 Simple Features wdi &lt;- read_csv(&quot;data/wdi.csv&quot;) # Einlesen der World Development Indicators wdi &lt;- wdi %&gt;% filter(jahr==2018) # Einschränkung auf das aktuellste Jahr im geo &lt;- read_rds(&quot;data/geo_wdi.rds&quot;) # Einlesen der Geodaten # Geodaten werden per Join zum Datensatz hinzugefügt df &lt;- wdi %&gt;% left_join(geo, by = &quot;iso2c&quot;) %&gt;% st_as_sf() glimpse(df) ## Rows: 213 ## Columns: 24 ## $ iso2c &lt;chr&gt; &quot;AD&quot;, &quot;AE&quot;, &quot;AF&quot;, &quot;AG&quot;, &quot;AL&quot;, &quot;AM&quot;, &quot;AO&quot;, &quot;AR~ ## $ land &lt;chr&gt; &quot;Andorra&quot;, &quot;United Arab Emirates&quot;, &quot;Afghanist~ ## $ kontinent &lt;chr&gt; &quot;Europe&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;North America&quot;, &quot;E~ ## $ subregion &lt;chr&gt; &quot;Southern Europe&quot;, &quot;Western Asia&quot;, &quot;Southern ~ ## $ jahr &lt;dbl&gt; 2018, 2018, 2018, 2018, 2018, 2018, 2018, 201~ ## $ bevölkerung &lt;dbl&gt; 77006, 9630959, 37172386, 96286, 2866376, 295~ ## $ bevölkerung_weiblich &lt;dbl&gt; NA, 30.63669, 48.63585, 51.78850, 49.06309, 5~ ## $ bevölkerung_0_14 &lt;dbl&gt; NA, 14.60351, 43.09018, 22.08109, 17.67287, 2~ ## $ `bevölkerung_65+` &lt;dbl&gt; NA, 1.085001, 2.584927, 8.799826, 13.744736, ~ ## $ bevölkerung_land &lt;dbl&gt; 11.938, 13.478, 74.505, 75.401, 39.681, 36.85~ ## $ bevölkerung_stadt &lt;dbl&gt; 88.062, 86.522, 25.495, 24.599, 60.319, 63.14~ ## $ `bevölkerung_unter$5.50` &lt;dbl&gt; NA, 0.1, NA, NA, NA, 42.5, 88.5, 12.3, NA, 1.~ ## $ bruttosozialprodukt &lt;dbl&gt; 3.218316e+09, 4.222150e+11, 1.835388e+10, 1.6~ ## $ fläche &lt;dbl&gt; 470.0, 98647.9, 652860.0, 440.0, 28750.0, 297~ ## $ lebenserwartung &lt;dbl&gt; NA, 77.81400, 64.48600, 76.88500, 78.45800, 7~ ## $ lebenserwartung_mann &lt;dbl&gt; NA, 77.133, 63.047, 75.721, 76.816, 71.215, 5~ ## $ lebenserwartung_frau &lt;dbl&gt; NA, 79.164, 66.026, 77.983, 80.167, 78.354, 6~ ## $ kindersterblichkeit &lt;dbl&gt; 2.9, 6.5, 48.0, 6.0, 8.5, 11.0, 51.9, 8.7, NA~ ## $ geburtenrate &lt;dbl&gt; NA, 1.413, 4.473, 1.994, 1.617, 1.755, 5.519,~ ## $ co2_emissionen &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ literacy_rate &lt;dbl&gt; NA, NA, 43.01972, NA, 98.14115, NA, NA, 99.00~ ## $ militärausgaben &lt;dbl&gt; NA, NA, 198074729, NA, 175886689, 608854650, ~ ## $ mordrate &lt;dbl&gt; NA, NA, 6.6555612, NA, 2.2894924, 1.6939156, ~ ## $ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((1.706055 42..., ~ Es handelt sich nicht um einen gewöhnlichen R Datensatz (data frame), sondern um einen sogenannten Simple Feature Datensatz. Das besondere daran ist die Variable geometry, welche die Koordinaten (Längengrad und Breitengrad) der Ländergrenzen enthält. Analog zum bisherigen Vorgehen, benötigen wir für die Visualisierung einer Weltkarte nur 3 Dinge: (1) den (Simple Feature) Datensatz, (2) eine Ästhetikzuordnung (die Variable geometry wird der Ästhetik geometry zugeordet, und (3) den passenden Objecttyp geom_sf. ggplot(data = df, mapping = aes(geometry = geometry)) + geom_sf() Tatsächlich können wir hier die Ästhetikzuordnung sogar weglassen, die Spezifikation des Datensatzes und geom_sf ist hier sogar ausreichend. ggplot(df) + geom_sf() Was bedeutet der Begriff feature? Ein Feature kann grundsätzlich alles mögliche sein (Land, Fluss, Bushaltestelle), in unserem Fall ist es ein Land. Features können durch unterschiedliche Geometrien repräsentiert werden: eine Bushaltestelle durch einen Punkt, ein Fluss durch eine Linie, ein Land durch ein Polygon oder Multipolygon. Beispielsweise kann das Vereinigte Königreich nur durch einen Multipolygon repräsentiert werden, da es aus zwei Inseln (jeweils Polygone) besteht. uk &lt;- df %&gt;% filter(land == &quot;United Kingdom&quot;) ggplot(uk) + geom_sf() uk[[&quot;geometry&quot;]][[1]][[1]] # Dies sind die Koordinaten von Irland ## [[1]] ## [,1] [,2] ## [1,] -1.065576 50.69023 ## [2,] -1.149365 50.65571 ## [3,] -1.175830 50.61523 ## [4,] -1.196094 50.59922 ## [5,] -1.251465 50.58882 ## [6,] -1.306299 50.58853 ## [7,] -1.515332 50.66978 ## [8,] -1.563428 50.66611 ## [9,] -1.515674 50.70332 ## [10,] -1.385840 50.73354 ## [11,] -1.312793 50.77349 ## [12,] -1.144238 50.73472 ## [13,] -1.065576 50.69023 3.2 Ästhetiken Die wichtigste Ästhetik ist bei Karten in der Regel die Füllfarbe (fill). Wie bisher können sie sie entweder die Füllfarbe entweder auf eine bestimmte Ausprägung (bspw. red) fixieren, oder eine Variable des Datensatzes der Füllfarbe zuordnen (aesthetic mapping). Zu beachten: Die Farbe der Landesgrenzen können über color Ästhetik beeinflusst werden. map &lt;- df %&gt;% ggplot() map + geom_sf(aes(fill=kontinent)) # nominal-skalierte Variable map + geom_sf(aes(fill=lebenserwartung)) # kardinal-skalierte Variable map + geom_sf(aes(fill=lebenserwartung), color = NA) # fest definierte Länderfarbe (hier unsichtbar) 3.3 Schichten Wie bisher können Sie auch hier über zusätzliche geom_[typ] Funktionen weitere Schichten definieren. Dies ist auch hier insbesondere für Hervorhebungen hilfreich. auswahl &lt;- df %&gt;% filter(land %in% c(&quot;Germany&quot;, &quot;Brazil&quot;, &quot;China&quot;, &quot;South Africa&quot;)) map + geom_sf(aes(fill=kontinent)) + geom_sf_label(data = auswahl, aes(label=land)) 3.4 Aggregation In manchen Situationen möchten wir die Daten durch eine Aggregation verdichten, bspw. um die durchschnittliche Lebenserwartung je Kontinent zu berechnen. kontinente &lt;- df %&gt;% group_by(kontinent) %&gt;% summarise(lebenserwartung = mean(lebenserwartung, na.rm=TRUE)) kontinente ## Simple feature collection with 7 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -55.8917 xmax: 180 ymax: 83.59961 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## # A tibble: 7 x 3 ## kontinent lebenserwartung geometry ## &lt;chr&gt; &lt;dbl&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 Africa 63.4 (((-2.938306 5.124495, -2.94834 5.118848, -3.~ ## 2 Asia 74.3 (((122.9489 -10.90928, 122.8559 -10.90967, 12~ ## 3 Europe 79.3 (((55.79736 -21.33936, 55.65615 -21.36904, 55~ ## 4 North America 76.0 (((-78.89834 8.274268, -78.91812 8.231934, -7~ ## 5 Oceania 73.4 (((158.8788 -54.70977, 158.8452 -54.74922, 15~ ## 6 Seven seas (op~ 75.3 (((57.65127 -20.48486, 57.5248 -20.51318, 57.~ ## 7 South America 74.9 (((-67.5752 -55.88965, -67.61143 -55.8917, -6~ Die gute Nachricht: bei der Aggregation wird auch die geometry Variable so aktualisiert, dass diese nun die Umrisse der jeweiligen Kontinente repräsentiert. kontinente %&gt;% ggplot() + geom_sf(aes(fill = lebenserwartung), color = NA) 3.5 Koordinatensystem Bisher haben wir das Thema Koordinatensystem nicht explizit angesprochen. Im Kontext von Karten ist es aber besonders relevant, da unsere 3-dimensionale Erde nicht akurat in 2 Dimensionen dargestellt werden kann. Es stehen uns nun unterschiedlich Projektionen zu Verfügung, die jeweils vorgeben, wo die Längen- und Breitengrade in den zwei Dimensionn verortet werden. Betrachten wir nun folgende Basiskarte: (basiskarte &lt;- df %&gt;% ggplot() + geom_sf(aes(fill = kontinent), color = NA) + scale_fill_brewer(palette = &quot;Set1&quot;)) Die Mercator Projection stellt Formen und Winkel korrekt dar, aber in Richtung der Pole wird die Größe der Länder künstlich aufgebläht. basiskarte + coord_sf(crs = st_crs(&quot;+proj=merc&quot;)) Hingegen werden bei der Lambert Azimuthal Equal Area (LAEA) Projektion die Ländergrößen korrekt dargestellt, wobei aber eine Verzerrung der Formen und Winkel in Kauf genommen wird. Auch der Perspektivwechsel auf einen anderen Mittelpunkt (hier Lhasa, Tibet) kann einen Mehrwert bzgl. der Interpretation schaffen. basiskarte + coord_sf(crs = st_crs(&quot;+proj=laea + lat_0=29.6490404 + lon_0=91.0052352&quot;)) "],["aggregierte-daten.html", "4 Aggregierte Daten 4.1 Sortierung 4.2 Überlappungen 4.3 Zwei kategoriale Variablen", " 4 Aggregierte Daten Das Thema Visualisierung von aggregierten Daten erschließen wir uns erneut anhand von Daten zu Gebrauchtwagenangeboten über Ebay Kleinanzeigen. library(tidyverse) theme_set(theme_bw()) df &lt;- read_csv(&quot;data/gebrauchtwagen.csv&quot;) glimpse(df) ## Rows: 20,000 ## Columns: 13 ## $ name &lt;chr&gt; &quot;smart_forTwo_Softtouch__passion_Inspektion_fuer_687_Euro_~ ## $ preis &lt;dbl&gt; 5299, 1100, 8199, 8999, 3600, 2490, 15500, 2700, 6200, 279~ ## $ alter &lt;dbl&gt; 7, 16, 14, 8, 13, 11, 7, 12, 8, 8, 22, 8, 9, 15, 16, 18, 1~ ## $ kilometer &lt;dbl&gt; 30000, 125000, 150000, 150000, 150000, 150000, 150000, 900~ ## $ hersteller &lt;chr&gt; &quot;smart&quot;, &quot;renault&quot;, &quot;audi&quot;, &quot;mercedes_benz&quot;, &quot;bmw&quot;, &quot;peuge~ ## $ modell &lt;chr&gt; &quot;fortwo&quot;, &quot;clio&quot;, &quot;a4&quot;, &quot;c_klasse&quot;, &quot;3er&quot;, &quot;1_reihe&quot;, &quot;5er~ ## $ fahrzeugtyp &lt;chr&gt; &quot;kleinwagen&quot;, &quot;kleinwagen&quot;, &quot;kombi&quot;, &quot;limousine&quot;, &quot;limousi~ ## $ getriebe &lt;chr&gt; &quot;automatik&quot;, &quot;manuell&quot;, &quot;automatik&quot;, &quot;automatik&quot;, &quot;manuell~ ## $ ps &lt;dbl&gt; 71, 75, 131, 136, 116, 68, 177, 69, 125, 67, 115, 121, 129~ ## $ kraftstoff &lt;chr&gt; &quot;benzin&quot;, &quot;benzin&quot;, &quot;benzin&quot;, &quot;diesel&quot;, &quot;benzin&quot;, &quot;diesel&quot;~ ## $ schaden &lt;chr&gt; &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;nein&quot;, &quot;j~ ## $ plz &lt;dbl&gt; 35315, 36137, 85057, 10627, 65934, 14793, 28816, 30880, 71~ ## $ bundesland &lt;chr&gt; &quot;Hessen&quot;, &quot;Hessen&quot;, &quot;Bayern&quot;, &quot;Berlin&quot;, &quot;Hessen&quot;, &quot;Branden~ Bis hierhin haben wir hauptsächlich Rohdaten visualisiert. Nun wollen wir hingegen die Rohdaten auf eine höhere Ebene aggregieren und diese Ergebnisse visualisieren, z.B: Anzahl Autos je Fahrzeugtyp (SUV, Cabrio, Kleinwagen, etc) Durchschnittlicher Preis je Hersteller data &lt;- df %&gt;% group_by(fahrzeugtyp) %&gt;% summarise(n = n(), preis = mean(preis)) data ## # A tibble: 5 x 3 ## fahrzeugtyp n preis ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 cabrio 1639 8342. ## 2 kleinwagen 5418 3288. ## 3 kombi 4938 6130. ## 4 limousine 6974 5971. ## 5 suv 1031 11800. Der wichtigste Grafiktyp für diese Art von Daten ist das Balkendiagramm (Bar chart), welches wir über das geometrische Object geom_col erezugen können. data %&gt;% ggplot(aes(x = fahrzeugtyp, y = n)) + geom_col() Eine praktische Alternative zu geom_col ist geom_bar, jedoch noch für den Fall, dass die Anzahl der Beobachtungen dargestellt werden soll. Die Funktion geom_bar kann direkt auf die Rohdaten angewendet werden. Hierbei wird das Zählen der Fälle implizit durch die Funktion ausgeführt und muss nicht explizit per Code berechnet werden. df %&gt;% ggplot(aes(x = fahrzeugtyp)) + geom_bar() 4.1 Sortierung Ein typisches Problem ist, dass eine Text-Variable (character) wie fahrzeugtyp zunächst einmal nur alfabetisch sortiert werden kann. Für eine bessere Interpretierbarkeit ist es jedoch meistens sinnvoll, die Balken sortiert nach ihrer Höhe anzuordnen. Dafür müssen wie die Text-Variable in eine sogenannte Faktor-Variable (factor) umwandenln. Faktoren lassen sich nach unterschiedlichsten Kriterien sortieren, bspw. über die Funktion fct_reorder. data %&gt;% ggplot(aes(x = fct_reorder(fahrzeugtyp, -preis), y = preis)) + geom_col() 4.2 Überlappungen Eine weitere typische Schwierigkeit besteht in sich überlappenden Labels. Dieses Problem tritt insbesondere auf der x-Achse auf. Deshalb lohnt es sich, die Achsenzuordnung zu ändern und so ein horizontales Balkendiagramm zu erzeugen. # Map to y axis data &lt;- df %&gt;% group_by(bundesland) %&gt;% summarise(n = n(), preis = mean(preis)) data %&gt;% ggplot(aes(x = bundesland, y = preis)) + geom_col() data %&gt;% ggplot(aes(y = bundesland, x = preis)) + geom_col() Eine weitere Möglichkeit besteht darin, mehrere kleinere Balken zu einem großen Balken für Sonstige zusammenzufassen. df %&gt;% ggplot(aes(y = fct_lump(bundesland, n= 5))) + geom_bar() 4.3 Zwei kategoriale Variablen Wenn wir die aggregierten Statistiken nicht für eine sondern zwei kategorielle Variablen berechnen (bspw. für bundesland und fahrzeugtyp), gibt es mehrere denkbare Darstellungsformen. Eine Heatmap via geom_tile eignet sich insbesondere, wenn die kategorialen Variablen viele Ausprägungen haben, so wie es hier der Fall ist. df %&gt;% count(bundesland, fahrzeugtyp) %&gt;% ggplot() + geom_tile(aes(x = fahrzeugtyp, y = bundesland, fill = n), color = &quot;white&quot;) + geom_text(aes(x = fahrzeugtyp, y = bundesland, label = n), size = 3) + scale_fill_binned(low = &quot;white&quot;, high = &quot;red&quot;) Facetten-Plots können grundsätzlich auch für solche Fälle helfen. Im hier vorliegenden Fall, mit vielen Ausprägungen wird ein Facettenplot aber schnell unübersichtlich. df %&gt;% count(bundesland, fahrzeugtyp) %&gt;% ggplot() + geom_col(aes(y = fahrzeugtyp, x = n)) + facet_wrap(~bundesland, scales = &quot;free&quot;) "],["zeit.html", "5 Zeit", " 5 Zeit Das Thema Zeitbezug erschließen wir uns anhand von Daten zu Luft-Schadstoffmessungen an ausgewählten Standorten in Deutschland seit 2006. Ausgewählt wurden neben zwei Kieler Standorten 6 Standorte mit überwiegend hohen Werten (für unterschiedliche Schadstofftypen). Zu beachten ist, dass im Datensatz auch eine große Anzahl an fehlender Werte (NA) enthalten sind. library(tidyverse) library(sf) df &lt;- read_csv(&quot;data/schadstoffe-zeitreihen.csv&quot;) glimpse(df) ## Rows: 39,001 ## Columns: 14 ## $ standort_id &lt;chr&gt; &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115&quot;, &quot;deby115~ ## $ standort &lt;chr&gt; &quot;München/Landshuter Allee&quot;, &quot;München/Landshuter Alle~ ## $ datum &lt;date&gt; 2006-01-01, 2006-01-02, 2006-01-03, 2006-01-04, 200~ ## $ kohlenmonoxid &lt;dbl&gt; 0.9445625, 1.1983400, 0.9279800, 0.6893000, 0.676340~ ## $ stickstoffmonoxid &lt;dbl&gt; 90.25696, 141.18668, 116.77000, 58.74500, 53.13500, ~ ## $ stickstoffdioxid &lt;dbl&gt; 99.14758, 80.95000, 79.06500, 57.35332, 50.00500, 53~ ## $ stickoxide &lt;dbl&gt; 237.2274, 297.2742, 258.1775, 147.5283, 131.4792, 10~ ## $ feinstaub10 &lt;dbl&gt; 59.47917, 38.29084, 29.28584, 21.94332, 27.47916, 34~ ## $ feinstaub2.5 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ ozon &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ schwefeldioxid &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ~ ## $ typ &lt;chr&gt; &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic&quot;, &quot;traffic~ ## $ gebiet &lt;chr&gt; &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;, &quot;urban&quot;~ ## $ hoehe &lt;dbl&gt; 521, 521, 521, 521, 521, 521, 521, 521, 521, 521, 52~ Der Zeit-Aspekt bringt einige Besonderheiten mit sich. Unter anderem wollen wir prüfen, ob die Entwicklung von Luftqualitätsmessungen einem bestimmten Saisonalen (oder anderartigem) Muster unterliegt. Dafür extrahieren wir aus der Datumsvariable zunächst zusätzliche Informationen. df &lt;- df %&gt;% mutate(jahr = lubridate::year(datum), tagimjahr = lubridate::yday(datum), monat = lubridate::month(datum, label=TRUE, abbr = TRUE), wochentag = lubridate::wday(datum, label=TRUE, abbr = TRUE)) Das besondere an den Variablen monat und wochentag ist, dass es sich hierbei um ordinal-skalierte Variablen handelt (ordered factors). Dies hat den Vorteil, dass sie sprechend als Januar, Februar, etc. dargestellt werden, sie aber der natürlichen Sortierung unterliegen. Überprüfen lässt sich der Variablentyp wie folgt: class(df$monat) ## [1] &quot;ordered&quot; &quot;factor&quot; Zunächst fokussieren wir uns auf die Besonderheiten bzgl. der Visualisierung einer einzelnen Zeitreihe. Dazu beschränkten wir den Zeitreihen-Datensatz auf einen Standort. muenchen &lt;- df %&gt;% dplyr::filter(standort == &quot;München/Landshuter Allee&quot;) Es stellt sich die Frage nach einem geeigneten geometrischen Objekt (geometric object). Grundsätzlich eignen sich Liniendiagramme (geom_line) gut für Zeitreihen. Aufgrund der hier vorliegenden starken Schwankungen kann es aber Sinn machen, die einzelnen Messpunkte (geom_point) darzustellen. Um den langfristigen Trend zu verdeutlichen eignet sich eine geglättete Trendlinie (geom_smooth). p &lt;- muenchen %&gt;% ggplot(aes(datum, stickstoffdioxid)) p + geom_line() p + geom_point() p + geom_line() + geom_smooth() Es lässt sich bereits erahnen, dass im vorliegenden Fall die Schwankungen einem bestimmten Muster mit Zeitbezug folgen. Schauen wir uns ein einzelnes Jahr konkreter an. Bei stickstoffdioxid scheint im Jahr 2019 kein klares saisonales Muster vorzuliegen. Wir können an diesem Beispiel aber demonstrieren, wie sich die Datum-Labels und die Gitterlinien anpassen lassen. Die unzähligen Formatierungsoptionen für Datums-Labels können via help(strftime) nachfollzogen werden. p &lt;- muenchen %&gt;% filter(jahr==2019) %&gt;% ggplot(aes(datum, stickstoffdioxid)) + geom_line() + geom_smooth() p + scale_x_date(date_labels = &#39;%D&#39;) p + scale_x_date(date_labels = &#39;%a, %d. %B %y&#39;, date_breaks = &quot;4 months&quot;, date_minor_breaks = &quot;1 months&quot;) Um nachzuvollziehen, ob sich ein bestimmtes saisonales Muster nur in einem Jahr zeigt, oder in allen Jahren, können wir die Variable jahr der Ästhetik Farbe zuordnen. Das funktioniert allerdings nur, wenn sie die numerische Variable jahr in eine kategoriale Variable (factor) umwandeln. Speziell geeignet ist hier wieder die Ordinal-Skalierung (ordered). muenchen %&gt;% ggplot(aes(tagimjahr, stickstoffdioxid, color = ordered(jahr))) + geom_smooth(se=FALSE) Um den Tag im Jahr sprechender zu gestalten, bedienen wir uns eines Tricks: muenchen %&gt;% mutate(datum0 = as.Date(&quot;1970-01-01&quot;) + tagimjahr) %&gt;% ggplot(aes(datum0, feinstaub10, color = ordered(jahr)))+ geom_smooth(se=FALSE) + scale_x_date(date_labels = &quot;%B&quot;) "]]
